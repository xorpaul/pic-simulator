#summary Beantwortung der Fragen.

==Allgemeines:==
 * *Grundsätzliche Arbeitsweise eines Simulators.*
    Die Simulation oder Simulierung ist eine Vorgehensweise zur Analyse von Systemen, die für die theoretische oder formelmäßige Behandlung zu kompliziert sind. Dies ist überwiegend bei dynamischem Systemverhalten gegeben. Bei der Simulation werden Experimente an einem Modell durchgeführt, um Erkenntnisse über das reale System zu gewinnen. 
    Im Zusammenhang mit Simulation spricht man von dem zu simulierenden System und von einem Simulator als Implementierung oder Realisierung eines Simulationsmodells. Letzteres stellt eine Abstraktion des zu simulierenden Systems dar (Struktur, Funktion, Verhalten). Der Ablauf des Simulators mit konkreten Werten (Parametrisation) wird als Simulationsexperiment bezeichnet. Dessen Ergebnisse können dann interpretiert und auf das zu simulierende System übertragen werden.

 * *Vor- und Nachteile einer Simulation.*
  * Vorteile:
    * Eine Untersuchung am realen System wäre zu aufwändig, zu teuer oder zu gefährlich.
    * Das reale System existiert (noch) nicht.
    * Für Experimente kann ein Simulationsmodell wesentlich leichter modifiziert werden als das reale System.
    * Spiel und Spaß an simulierten Szenarien.
  * Nachteile:
    * Rechenkapazität, Zeit und Geld
    * Die Resultate können falsch sein

 * *Programmoberfläche und deren Handhabung.*
     siehe [http://code.google.com/p/pic-simulator/wiki/screenshotgui Screenshot der GUI]

==Zusammenfassung:==
 * *Wie weit konnten die Funktionen des Bausteins per Software nachgebildet werden?*
    Die Funktionen des Bausteins wurden alle in einer Klasse (PicCPU) zusammengefasst. Die zwei Speicherbänke wurden hierbei durch zwei eigenständige Arrays getrennt, wodurch zusätzlicher Aufwand zur Verwaltung der geraden aktiven Bank, sowie der Synchronisation einiger Speziellen Register und der indirekte Zugriff (Stichwort FSR) Teilweise komplizierter wurde. Des Weiteren wurde das Status-Register zusätzlich als separates Array implementiert um den Zugriff auf dieses zu erleichtern, wodurch aber wiederum ein ständiger Abgleich zur Speicherbank 0 gewährleistet sein muss. Zudem besteht die Möglichkeit das Status Register in jedem Bit zu manipulieren was nicht dem Hardware-Original entspricht, hier liegt eine mögliche Quelle für spätere Programmfehler. Der Befehlssatz des Bausteines wurde ebenfalls komplett in der PicCPU Klasse implementiert, wobei für jede Funktion eine eigene Methoden und zugehörige Hilfsmethoden für Latch-Funktion, indirekter Zugriff auf Register sowie Synchronisation, geschrieben wurden. Dies Funktionen werden von der InterpreterKlasse aufgrund des eingelesenen Opcodes aufgerufen, welche auch den Programmcounter enthält. Dies wurde deshalb auf diese Weise implementiert, da der Programmcounter ein elementares Element der Interpreterschleife darstellt und der Zugriff des Bausteines auf diesen Wert eher Zweitrangig erschien.
 * *Fazit, persönliche Erfahrung und Erkenntnis. Was passierte während der Entwicklung des Projektes? Welche Probleme tauchten auf und wie wurden Sie gelöst. Vermeiden Sie dabei negative Formulierungen. Was würde ich anderst machen, wenn ich das Projekt nochmals realisieren müsste? (Umfang des Fazits ca. 10% der Ausarbeitung) *
    Größtes Problem bei der Entwicklung war der nachträgliche Einbau bestimmter Hardwareeigenschaften wie Interrupt und Latch-Funktion aber auch anderen Elementen. Zunächst wurde ein Grundprogramm entwickelt das lediglich reinen Opcode zeilenweise einlesen und interpretieren konnte. Aufbauend auf diesem Gerüst sollten dann alle weitern Funktionen nach und nach hinzugefügt werden, was immer wieder zu kleinen, aber nicht unlösbaren Problemen führte. Hauptproblem war jedoch stets  die Mangelnde Kenntnis über die Eigenschaften des Bausteins, sodass manche Funktionen erst sehr spät oder womöglich sogar gar nicht programmiert wurden und somit eine Fehlerquelle darstellen. Weiteres Problem war ebenfalls das relativ geringe Wissen über die Implementierungssprache (Java), sodass viele Funktionen nicht so effizient und/oder elegant gelöst wurden wie es vielleicht Möglich gewesen währe. Gelöst wurden diese zwei Kernprobleme dadurch das sich immer hilfreiche Kommilitonen fanden, die mit ihrem Wissen aushelfen konnten, sowohl im Bezug auf die Funktionsweise des Bausteines, als auch bei Problemen der Implementierung. Positiv hervorzuheben ist die reibungslose Zusammenarbeit beim Codedesign. Auch wenn es sich an manchen Stellen eventuell angeboten hätte den Code in weitere Klassen aufzusplitten, so wurde am Klassendesign und an dem Grundkonzept wie es am Anfang erdacht wurde während der Gesamten Entwicklung nichts geändert, genauso wenig wie an dem weiteren Code der von den einzelnen Projektmitgliedern Stück für Stück hinzugefügt wurde. In den meisten Fällen war der abgelieferte Code immer lauffähig und Produzierte die richtigen Ergebnisse. Probleme gab es nur an Stellen die etwas Komplizierter waren. An diesen Stellen wurden die dadurch entstandenen Fehler durch Absprachen und gemeinsamen Programmier-Sessions korrigiert.
    Wenn das Projekt ein weiteres Mal implementiert werden sollte, sollte man sich auf jeden Fall die Funktionsweise und Features des Bausteines genauer betrachten bevor man damit beginnt zu implementieren. Hierbei kann man schon auf Bestandteile eingehen die womöglich erst zu einem späteren Zeitpunkt in die Entwicklung einfließen und das Grundgerüst des Simulators schon von vorne herein auf diese hin entwickeln. Zudem würde womöglich der Programmierstil eine wesentlich effizientere Gestaltung des Codes erlauben, da durch dieses, aber auch durch andere Projekte, die Erfahrung in der Implementierungssprache zugenommen hat.  